const CONTAINER_NAME = :_SimplePlutoInclude_

abstract type FileStatus end
struct UpToDate <: FileStatus end
abstract type ShouldWarn <: FileStatus end
struct NoNames <: ShouldWarn 
    file::String
end
struct OldVersion <: ShouldWarn 
    current_mtime
    plutoinclude_helpers
end
struct DifferentFile <: ShouldWarn 
    current_path::String
    plutoinclude_helpers
end

# This just increase font inside logs as it's too small
increase_log_font(content) = """
$content
<script>
    const this_log_dot = currentScript.closest('pluto-log-dot')
    console.log(currentScript, this_log_dot)
    if (this_log_dot === null) {return}
    this_log_dot.style['font-size'] = '.8rem'
</script>
""" |> Docs.HTML

output_html(content) = Docs.HTML(content * "<br>Check the cell logs for more details.")

function Base.show(io::IO, mime::MIME"text/html", status::NoNames)
    (;file) = status
    info = "<b>@plutoinclude ERROR:</b> The macro did not import any name.<br>Consider setting the <b>'all'</b> kwarg to <b>true</b> or add <b>'export'</b> statements within the included file, <b>and then re-run this cell manually</b>."
    @error increase_log_font(info) file
    show(io, mime, output_html(info))
end
function Base.show(io::IO, mime::MIME"text/html", status::OldVersion)
    (;current_mtime, plutoinclude_helpers) = status
    (; compiled_path, compiled_mtime) = plutoinclude_helpers
    file = compiled_path
    current_mtime = unix2datetime(current_mtime)
    compiled_mtime = unix2datetime(compiled_mtime)
    info = "<b>@plutoinclude WARNING:</b> The file was updated since macro compilation.<br><b>Rerun this cell manually</b> to recompile the macro and use the latest version of the file."
    @warn increase_log_font(info) file current_mtime compiled_mtime
    show(io, mime, output_html(info))
end
function Base.show(io::IO, mime::MIME"text/html", status::DifferentFile) 
    (; current_path, plutoinclude_helpers) = status
    (; compiled_path) = plutoinclude_helpers

    file_exists = isfile(current_path)
    info = "The target points to a different file.<br>"
    info = if file_exists
        "<b>@plutoinclude WARNING:</b> " * info * "<b>Rerun this cell manually</b> to recompile the macro and use the correct file."
    else
        "<b>@plutoinclude ERROR:</b> " * info * "<b>The updated path does not seem to point to an existing file</b>.<br> Correct the path and eventually rerun the cell."
    end
    if file_exists
        @warn increase_log_font(info) current_path compiled_path
    else
        @error increase_log_font(info) current_path compiled_path
    end
    show(io, mime, output_html(info))
end

# Custom function to check if we are inside Pluto
is_inside_pluto(lnn::LineNumberNode) = is_inside_pluto(lnn.file |> String)
function is_inside_pluto(calling_file::String)
    parts = split(calling_file, "#==#")
    length(parts) === 2 || return false
    return length(last(parts)) === 36
end

function get_module_container()
    isdefined(Main, CONTAINER_NAME) && return getproperty(Main, CONTAINER_NAME)::Module
    # We create an empty module that will contain the modules generated by 
    m = Core.eval(Main, :(baremodule $CONTAINER_NAME end))
    return m
end

function extract_names(m::Module; imported=false, all=true, kwargs...)
    nms = names(m; all, imported, kwargs...)
    # Exclude PlutoPkg names, `eval` and `include` as well as the module name itself from exporting. The module name is skipped as it will be a dummy module for `@plutoinclude` and it is assumed to be already defined for `@use_local_module`
    excluded = (:PLUTO_PROJECT_TOML_CONTENTS, :PLUTO_MANIFEST_TOML_CONTENTS, :eval, :include, Symbol("@bind"), nameof(m))
    filter(nms) do nm
        nm âˆ‰ excluded && !Base.isgensym(nm)
    end
end

function extract_abs_path(val_from_caller)
    @assert val_from_caller isa AbstractString "The provided target to the @plutoinclude macro does not seem to be a String."
    target = abspath(val_from_caller)
    return target
end

function extract_kwargs(inputs)
    kwargs = Dict{Symbol,Bool}()
    # Create a function that will evaluate the path expression in the caller module
    # If there is only one input, simply assume no kwargs
    if length(inputs) === 1
        return only(inputs), kwargs
    end
    iskwarg(ex) = Meta.isexpr(ex, :(=))
    kwargs_idxs = findall(iskwarg, inputs)
    nkwargs = isnothing(kwargs_idxs) ? 0 : length(kwargs_idxs)
    invalid_msg = 
    #! format: off
"The set of inputs provided to the @plutoinclude macro is not supported.
The supported inputs to the macro are:
- One single input representing the path to file to include, which will be evaluated during macro expansion in the calling module
- Any number of assignment expression of the form `name = value::Bool` which will be interpretd as keyword argument to use for extracting names from the file." 
    #! format: on
    @assert nkwargs === length(inputs) - 1 invalid_msg
    for idx in kwargs_idxs
        ex = inputs[idx]
        name, value = ex.args
        @assert value isa Bool "The kwarg associated to the name $name does not have a Boolean value."
        kwargs[name] = value
    end
    # Find the input arg which shall be interpreted as path
    target_idx = setdiff(1:length(inputs), kwargs_idxs) |> only
    target = inputs[target_idx]
    return target, kwargs
end

function get_macro_status(current_path, compiled_module)
    current_path = abspath(current_path)
    plutoinclude_helpers = compiled_module.plutoinclude_helpers
    (; compiled_path, compiled_mtime) = plutoinclude_helpers
    status = if current_path !== compiled_path
        DifferentFile(current_path, plutoinclude_helpers)
    elseif mtime(current_path) > compiled_mtime
        OldVersion(mtime(current_path), plutoinclude_helpers)
    else
        UpToDate()
    end
    return status
end

function module_and_names(m::Module, extract_names_func)
    # We force all and imported as we want to check if there is only one module inside the container
    nms = extract_names_func(m; all=true, imported=true)
    target_module = m
    if length(nms) === 1 
        only_item = getproperty(m, first(nms))
        only_item isa Module && (target_module = only_item)
    end
    # Now we extract the names correctly
    nms = extract_names_func(target_module)
    if m !== target_module
        # We also add the name of the inner module
        pushfirst!(nms, nameof(target_module))
    end
    return target_module, nms
end


function process_generated_module(generated_module::Module; path, target_ex, input_kwargs)
    extract_names_func = (m; kws...) -> extract_names(m; input_kwargs..., kws...)
    target_module, extracted_names = module_and_names(generated_module, extract_names_func)
    inner_module = target_module === generated_module
    compiled_mtime = mtime(path)
    compiled_path = path
    pluoinclude_helpers = (;
        extracted_names,
        target_ex,
        extract_names_func,
        compiled_mtime,
        compiled_path,
        inner_module
    )
    # Add the helpers inside the module
    Core.eval(target_module, :(plutoinclude_helpers = $pluoinclude_helpers))
    return target_module
end

function plutoinclude(target_ex, val_from_caller; input_kwargs)
    path = extract_abs_path(val_from_caller)
    modex = :(module $(Symbol(path))
    include($path)
    end)
    # We create a module inside our own custom container outside of Pluto so it's not garbage collected by Pluto
    generated_module = Base.redirect_stderr(Pipe()) do
        Core.eval(get_module_container(), modex)
    end
    # This process the generated module to extract the target module which contains a plutoinclude_helpers namedtuple.
    m = invokelatest(process_generated_module, generated_module; path, target_ex, input_kwargs)
    # We put the module inside a temporary variable in Main
    return invokelatest(expr_from_module, m)
end

# the module_name_in_pluto kwarg will contain the name of the module in Pluto if this is called from `@plutousing` and `nothing` if called from `@plutoinclude`
function expr_from_module(m::Module)
    isdefined(m, :plutoinclude_helpers) || error("The expr_from_module function only works with modules generated by @plutoinclude")
    (;
        extracted_names,
        target_ex,
        compiled_path
    ) = getproperty(m, :plutoinclude_helpers)
    path_symbol = Symbol(compiled_path)
    # Return nothing if no names have been extracted
    isempty(extracted_names) && return :($NoNames($compiled_path))
    # We put the module inside a temporary variable in Main for consistent importing
    nms_expr = map(nm -> Expr(:., nm), extracted_names)
    modexpr = Expr(:., :., path_symbol)
    ex = Expr(:import, Expr(:(:), modexpr, nms_expr...))
    # We put the warn msg both as log and as output as people might have logs disabled for the specific cell
    return quote
        # We put in scope the name of the generated module
        $path_symbol = $m
        local status = $get_macro_status($target_ex, $path_symbol)
        $ex # This is the actual import
        status isa $ShouldWarn ? status : nothing
    end
end