module SimplePlutoInclude

using Dates: Dates, unix2datetime

export @plutoinclude

const CONTAINER_NAME = :_SimplePlutoInclude_

abstract type FileStatus end
struct UpToDate <: FileStatus end
abstract type ShouldWarn <: FileStatus end
struct NoNames <: ShouldWarn 
    file::String
end
struct OldVersion <: ShouldWarn 
    current_mtime
    plutoinclude_helpers
end
struct DifferentFile <: ShouldWarn 
    current_path::String
    plutoinclude_helpers
end

# This just increase font inside logs as it's too small
increase_log_font(content) = """
$content
<script>
    const this_log_dot = currentScript.closest('pluto-log-dot')
    console.log(currentScript, this_log_dot)
    if (this_log_dot === null) {return}
    this_log_dot.style['font-size'] = '.8rem'
</script>
""" |> Docs.HTML

output_html(content) = Docs.HTML(content * "<br>Check the cell logs for more details.")

function Base.show(io::IO, mime::MIME"text/html", status::NoNames)
    (;file) = status
    info = "<b>@plutoinclude ERROR:</b> The macro did not import any name.<br>Consider setting the <b>'all'</b> kwarg to <b>true</b> or add <b>'export'</b> statements within the included file, <b>and then re-run this cell manually</b>."
    @error increase_log_font(info) file
    show(io, mime, output_html(info))
end
function Base.show(io::IO, mime::MIME"text/html", status::OldVersion)
    (;current_mtime, plutoinclude_helpers) = status
    (; compiled_path, compiled_mtime) = plutoinclude_helpers
    file = compiled_path
    current_mtime = unix2datetime(current_mtime)
    compiled_mtime = unix2datetime(compiled_mtime)
    info = "<b>@plutoinclude WARNING:</b> The file was updated since macro compilation.<br><b>Rerun this cell manually</b> to recompile the macro and use the latest version of the file."
    @warn increase_log_font(info) file current_mtime compiled_mtime
    show(io, mime, output_html(info))
end
function Base.show(io::IO, mime::MIME"text/html", status::DifferentFile) 
    (; current_path, plutoinclude_helpers) = status
    (; compiled_path) = plutoinclude_helpers

    file_exists = isfile(current_path)
    info = "The target points to a different file.<br>"
    info = if file_exists
        "<b>@plutoinclude WARNING:</b> " * info * "<b>Rerun this cell manually</b> to recompile the macro and use the correct file."
    else
        "<b>@plutoinclude ERROR:</b> " * info * "<b>The updated path does not seem to point to an existing file</b>.<br> Correct the path and eventually rerun the cell."
    end
    if file_exists
        @warn increase_log_font(info) current_path compiled_path
    else
        @error increase_log_font(info) current_path compiled_path
    end
    show(io, mime, output_html(info))
end

# Custom function to check if we are inside Pluto
is_inside_pluto() = isdefined(Main, :PlutoRunner) && 
Main.PlutoRunner isa Module && 
"Pluto" in Main.PlutoRunner |> pkgdir |> splitpath

function get_module_container()
    isdefined(Main, CONTAINER_NAME) && return getproperty(Main, CONTAINER_NAME)::Module
    # We create an empty module that will contain the modules generated by 
    m = Module(CONTAINER_NAME, false, false)
    return m
end

function extract_names(m::Module; imported=false, all=true, kwargs...)
    nms = names(m; all, imported, kwargs...)
    # Exclude PlutoPkg names, `eval` and `include` as well as the module name itself from exporting. The module name is skipped as it will be a dummy module for `@plutoinclude` and it is assumed to be already defined for `@use_local_module`
    excluded = (:PLUTO_PROJECT_TOML_CONTENTS, :PLUTO_MANIFEST_TOML_CONTENTS, :eval, :include, Symbol("@bind"), nameof(m))
    filter(nms) do nm
        nm âˆ‰ excluded && !Base.isgensym(nm)
    end
end

function extract_abs_path(val_from_caller)
    @assert val_from_caller isa AbstractString "The provided target to the @plutoinclude macro does not seem to be a String."
    target = abspath(val_from_caller)
    return target
end

function extract_kwargs(inputs)
    kwargs = Dict{Symbol,Bool}()
    # Create a function that will evaluate the path expression in the caller module
    # If there is only one input, simply assume no kwargs
    if length(inputs) === 1
        return only(inputs), kwargs
    end
    iskwarg(ex) = Meta.isexpr(ex, :(=))
    kwargs_idxs = findall(iskwarg, inputs)
    nkwargs = isnothing(kwargs_idxs) ? 0 : length(kwargs_idxs)
    invalid_msg = 
    #! format: off
"The set of inputs provided to the @plutoinclude macro is not supported.
The supported inputs to the macro are:
- One single input representing the path to file to include, which will be evaluated during macro expansion in the calling module
- Any number of assignment expression of the form `name = value::Bool` which will be interpretd as keyword argument to use for extracting names from the file." 
    #! format: on
    @assert nkwargs === length(inputs) - 1 invalid_msg
    for idx in kwargs_idxs
        ex = inputs[idx]
        name, value = ex.args
        @assert value isa Bool "The kwarg associated to the name $name does not have a Boolean value."
        kwargs[name] = value
    end
    # Find the input arg which shall be interpreted as path
    target_idx = setdiff(1:length(inputs), kwargs_idxs) |> only
    target = inputs[target_idx]
    return target, kwargs
end

function get_macro_status(current_path, compiled_module)
    current_path = abspath(current_path)
    plutoinclude_helpers = compiled_module.plutoinclude_helpers
    (; compiled_path, compiled_mtime) = plutoinclude_helpers
    status = if current_path !== compiled_path
        DifferentFile(current_path, plutoinclude_helpers)
    elseif mtime(current_path) > compiled_mtime
        OldVersion(mtime(current_path), plutoinclude_helpers)
    else
        UpToDate()
    end
    return status
end

function module_and_names(m::Module, extract_names_func)
    # We force all and imported as we want to check if there is only one module inside the container
    nms = extract_names_func(m; all=true, imported=true)
    target_module = m
    if length(nms) === 1 
        only_item = getproperty(m, first(nms))
        only_item isa Module && (target_module = only_item)
    end
    # Now we extract the names correctly
    nms = extract_names_func(target_module)
    if m !== target_module
        # We also add the name of the inner module
        pushfirst!(nms, nameof(target_module))
    end
    return target_module, nms
end


function process_generated_module(generated_module::Module; path, target_ex, input_kwargs)
    extract_names_func = (m; kws...) -> extract_names(m; input_kwargs..., kws...)
    target_module, extracted_names = module_and_names(generated_module, extract_names_func)
    inner_module = target_module === generated_module
    compiled_mtime = mtime(path)
    compiled_path = path
    pluoinclude_helpers = (;
        extracted_names,
        target_ex,
        extract_names_func,
        compiled_mtime,
        compiled_path,
        inner_module
    )
    # Add the helpers inside the module
    target_module.plutoinclude_helpers = pluoinclude_helpers
    return target_module
end

function plutoinclude(target_ex, val_from_caller; input_kwargs)
    path = extract_abs_path(val_from_caller)
    modex = :(module $(Symbol(path))
    include($path)
    end)
    # We create a module inside our own custom container outside of Pluto so it's not garbage collected by Pluto
    generated_module = Core.eval(get_module_container(), modex)
    # This process the generated module to extract the target module which contains a plutoinclude_helpers namedtuple.
    m = process_generated_module(generated_module; path, target_ex, input_kwargs)
    # We put the module inside a temporary variable in Main
    return expr_from_module(m)
end

# the module_name_in_pluto kwarg will contain the name of the module in Pluto if this is called from `@plutousing` and `nothing` if called from `@plutoinclude`
function expr_from_module(m::Module)
    isdefined(m, :plutoinclude_helpers) || error("The expr_from_module function only works with modules generated by @plutoinclude")
    (;
        extracted_names,
        target_ex,
        compiled_path
    ) = m.plutoinclude_helpers
    path_symbol = Symbol(compiled_path)
    # Return nothing if no names have been extracted
    isempty(extracted_names) && return :($NoNames($compiled_path))
    # We put the module inside a temporary variable in Main for consistent importing
    nms_expr = map(nm -> Expr(:., nm), extracted_names)
    modexpr = Expr(:., :., path_symbol)
    ex = Expr(:import, Expr(:(:), modexpr, nms_expr...))
    # We put the warn msg both as log and as output as people might have logs disabled for the specific cell
    return quote
        # We put in scope the name of the generated module
        $path_symbol = $m
        local status = $get_macro_status($target_ex, $path_symbol)
        $ex # This is the actual import
        status isa $ShouldWarn ? status : nothing
    end
end

"""
    @plutoinclude path [kwarg1 = value1, kwarg2 = value2, ...]

This macro simplify the inclusion of the file pointed at by `path` inside a Pluto notebook, and it simply becomes a no-op when called outside of a Pluto session.

The macro simply performs the following three steps: 
1. Create an empty temporary module inside the caller module
2. Include the target file within the temporary module
3. Explicitly imports the _names_ defined in the __included__ file in the current Pluto workspace

## Path
The path can be specified either as a plain String, or as an expression that evaluates to the string path in the caller module.

## Optional Keyword Arguments
Apart from the path, the macro also accepts additional inputs in the form `name = value` where `value` must be a `Bool`. These values are passed internally as keyword arguments to the `Base.names` function that is called to extract all names defined in the temporary module that included the file.

# Extended Help
## Basic Functionality
This macro tries to simplify the process of __including__ a julia file inside a Pluto notebook with the possibility of __reloading__ the file once its contents are updated.
The target file can be any valid julia file (including another Pluto notebook), and this macro simply performs the following steps:
1. Create an empty temporary module inside the caller module
2. Include the target file within the temporary module
3. Explicitly imports the _names_ defined in the __included__ file in the current Pluto workspace

> [!NOTE]
> The temporary module is created during macro expansion time in order to be able to extract the names and explicitly import them in the expression generated by the macro. **This means that reloading the contents of the file can only be done by _manually_ reloading the cell containing the `@plutoinclude` macro**.

> [!IMPORTANT]
> Any package that is imported or used within the included file must also be present in the environment of the notebook calling the `@plutoinclude` macro. 
> This macro tries to be as simple as possible and does not handles the environment of the included file. For more complex cases, consider using the other macros defined in [PlutoDevMacros.jl](https://github.com/disberd/PlutoDevMacros.jl)

## Specifying the file to include
The path to the file to be included can be specified either as a plain `String`, or as any expression that will evaluate to a String in the caller module (i.e. the Pluto workspace where the `@plutoinclude` macro is called).

An example use of `@plutoinclude` is fed a path as input based on a variable defined in the notebook is the following:
![image](https://github.com/disberd/SimplePlutoInclude.jl/assets/12846528/3eabe137-ca4a-46a3-a68b-a1c66a18d1aa)

> [!WARNING]
> When specifying the path as an expression depending on variables/functions defined in the notebook itself, the `@plutoinclude` macro might behave strangely as the code loading is happening during macro expansion. The following two _strange_ behaviors are important to know about when using variables/functions defined within the notebook as input to the macro:
> - The cell containing the macro might error when running for the first time after opening a notebook, depending on the cell loading order within the notebook. This is because the symbol/function is evaluated during the first macro expansion, so **before** the cell definining the symbol/function is first executed. This can easily be solved by manually re-running the cell with `@plutoinclude`.
> - The `@plutoinclude` macro will not reload the contents of the file upon _reactive_ run (i.e. when the cell is ran because one of its dependencies has been changed, and not because it was manually re-run). This is because the macro is not _expanded_/_compiled_ again upon _reactive_ run, so the module containing the _included_ file will not be re-created. 

## Customizing imported names
The names to be introduced into the Pluto workspace are simply extracted from the temporary module using `Base.names(tempmodule)`, and filtering out some of the output names (e.g. `gensym`-ed names and other like `eval` and `include`).

By default, the call to `Base.names` will have the `all` keyword argument set to true in order to export all names defined directly within the _included_ file.

The `@plutoinclude` macro accepts as additional inputs any number of assignments expression of the form `name = value` where `value` must be a `Bool`. These expression are parsed at the beginning of the macro expansion and grouped as `kwargs` that are passed to the `Base.names` call. One could example set the `all` kwarg to false as in the example below:
![image](https://github.com/disberd/SimplePlutoInclude.jl/assets/12846528/3abd2ac3-ce6d-40ac-8e54-a761ae205a6a)

> [!NOTE]
> Setting `all` to `false` will not export any name defined in the _included_ file unless something is explicitly marked with `export` or `public` within the file.

> [!NOTE]
> If you want to avoid exporting some specific variables from an included Pluto notebook, like for example the variables defined with `@bind`, consider marking them in the original notebook as _Disabled in file_, so they will be commented out in the source file and will not be _included_ in the temporary module generated by `@plutoinclude`.

## Alternatives
The functionality provided by the `@plutoinclude` macro is very similar to the `@ingredients` macro from [PlutoLinks.jl](https://github.com/JuliaPluto/PlutoLinks.jl). The main difference is the fact that while `@ingredients` does not explicitly import any name inside the calling Pluto notebook, `@plutoinclude` does.
This often simplifies interactive development as one does not need to always prepend the module name to access the variables defined within the file
> [!NOTE]
> `@ingredients` also tracks changes in the file and rerun dependent cells when updating the file. While a mode supporting `Revise` is planned for the next release of SimplePlutoInclude, automatic reload of dependent cells is not planned for this macro as the reload of the file is intended to only be done manually to accidentally avoid triggering long-running cells each time a file is changed. 
"""
macro plutoinclude(args...)
    is_inside_pluto() || return nothing # Do nothing outside of Pluto
    caller = __module__
    target_ex, input_kwargs = extract_kwargs(args)
    val_from_caller = Core.eval(caller, target_ex)
    plutoinclude(target_ex, val_from_caller; input_kwargs) |> esc
end

end # module SimplePlutoInclude
