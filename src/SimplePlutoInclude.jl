module SimplePlutoInclude

export @plutoinclude

# Custom function to check if we are inside Pluto
is_inside_pluto() = isdefined(Main, :PlutoRunner) && 
Main.PlutoRunner isa Module && 
"Pluto" in Main.PlutoRunner |> pkgdir |> splitpath

function extract_names(m::Module; imported=false, all=true, kwargs...)
    nms = names(m; all, imported, kwargs...)
    # Exclude PlutoPkg names and `eval` and `include` from exporting
    excluded = (:PLUTO_PROJECT_TOML_CONTENTS, :PLUTO_MANIFEST_TOML_CONTENTS, :eval, :include, Symbol("@bind"))
    filter(nms) do nm
        nm âˆ‰ excluded && !Base.isgensym(nm)
    end
end

function extract_kwargs(inputs, caller::Module)
    kwargs = Dict{Symbol,Bool}()
    # Create a function that will evaluate the path expression in the caller module
    resolve_path(ex) = Core.eval(caller, ex) |> abspath
    # If there is only one input, simply assume no kwargs
    if length(inputs) === 1
        return only(inputs) |> resolve_path, kwargs
    end
    iskwarg(ex) = Meta.isexpr(ex, :(=))
    kwargs_idxs = findall(iskwarg, inputs)
    nkwargs = isnothing(kwargs_idxs) ? 0 : length(kwargs_idxs)
    @assert nkwargs === length(inputs) - 1 "The set of inputs provided to the @plutoinclude macro is not supported.
The supported inputs to the macro are:
- One single input representing the path to file to include, which will be evaluated during macro expansion in the calling module
- Any number of assignment expression of the form `name = value::Bool` which will be interpretd as keyword argument to use for extracting names from the file."
    for idx in kwargs_idxs
        ex = inputs[idx]
        name, value = ex.args
        @assert value isa Bool "The kwarg associated to the name $name does not have a Boolean value."
        kwargs[name] = value
    end
    # Find the input arg which shall be interpreted as path
    path_idx = setdiff(1:length(inputs), kwargs_idxs) |> only
    path = resolve_path(inputs[path_idx])
    return path, kwargs
end

# This function will just warns that no names were extracted
function warn_no_names()
    msg = "No names were extracted from the generated module.\nConsider setting the `all` kwarg to `true` or specifically mark names with `export` within the included file"
    @warn msg
    "WARNING: $msg" |> Text
end

function plutoinclude(path::AbstractString, caller::Module; kwargs...)
    is_inside_pluto() || return nothing # Do nothing outside of Pluto
    @assert isabspath(path) "The plutoinclude function must be called with an absolute path as input"
    modname = Symbol(basename(path)) |> gensym
    modex = :(module $modname
    include($path)
    end)
    # Create module
    generated_module = Core.eval(caller, modex)
    # Extract names
    nms = extract_names(generated_module; kwargs...)
    # Return nothing if no names have been extracted
    isempty(nms) && return :($warn_no_names())
    nms_expr = map(nm -> Expr(:., nm), nms)
    modexpr = Expr(:., fullname(caller)..., modname)
    ex = Expr(:import, Expr(:(:), modexpr, nms_expr...))
end

"""
    @plutoinclude path [kwarg1 = value1, kwarg2 = value2, ...]

This macro simplify the inclusion of the file pointed at by `path` inside a Pluto notebook, and it simply becomes a no-op when called outside of a Pluto session.

The macro simply performs the following three steps: 
1. Create an empty temporary module inside the caller module
2. Include the target file within the temporary module
3. Explicitly imports the _names_ defined in the __included__ file in the current Pluto workspace

## Path
The path can be specified either as a plain String, or as an expression that evaluates to the string path in the caller module.

## Optional Keyword Arguments
Apart from the path, the macro also accepts additional inputs in the form `name = value` where `value` must be a `Bool`. These values are passed internally as keyword arguments to the `Base.names` function that is called to extract all names defined in the temporary module that included the file.

# Extended Help
## Basic Functionality
This macro tries to simplify the process of __including__ a julia file inside a Pluto notebook with the possibility of __reloading__ the file once its contents are updated.
The target file can be any valid julia file (including another Pluto notebook), and this macro simply performs the following steps:
1. Create an empty temporary module inside the caller module
2. Include the target file within the temporary module
3. Explicitly imports the _names_ defined in the __included__ file in the current Pluto workspace

> [!NOTE]
> The temporary module is created during macro expansion time in order to be able to extract the names and explicitly import them in the expression generated by the macro. **This means that reloading the contents of the file can only be done by _manually_ reloading the cell containing the `@plutoinclude` macro**.

> [!IMPORTANT]
> Any package that is imported or used within the included file must also be present in the environment of the notebook calling the `@plutoinclude` macro. 
> This macro tries to be as simple as possible and does not handles the environment of the included file. For more complex cases, consider using the other macros defined in [PlutoDevMacros.jl](https://github.com/disberd/PlutoDevMacros.jl)

## Specifying the file to include
The path to the file to be included can be specified either as a plain `String`, or as any expression that will evaluate to a String in the caller module (i.e. the Pluto workspace where the `@plutoinclude` macro is called).

An example use of `@plutoinclude` is fed a path as input based on a variable defined in the notebook is the following:
![image](https://github.com/disberd/SimplePlutoInclude.jl/assets/12846528/3eabe137-ca4a-46a3-a68b-a1c66a18d1aa)

> [!WARNING]
> When specifying the path as an expression depending on variables/functions defined in the notebook itself, the `@plutoinclude` macro might behave strangely as the code loading is happening during macro expansion. The following two _strange_ behaviors are important to know about when using variables/functions defined within the notebook as input to the macro:
> - The cell containing the macro might error when running for the first time after opening a notebook, depending on the cell loading order within the notebook. This is because the symbol/function is evaluated during the first macro expansion, so **before** the cell definining the symbol/function is first executed. This can easily be solved by manually re-running the cell with `@plutoinclude`.
> - The `@plutoinclude` macro will not reload the contents of the file upon _reactive_ run (i.e. when the cell is ran because one of its dependencies has been changed, and not because it was manually re-run). This is because the macro is not _expanded_/_compiled_ again upon _reactive_ run, so the module containing the _included_ file will not be re-created. 

## Customizing imported names
The names to be introduced into the Pluto workspace are simply extracted from the temporary module using `Base.names(tempmodule)`, and filtering out some of the output names (e.g. `gensym`-ed names and other like `eval` and `include`).

By default, the call to `Base.names` will have the `all` keyword argument set to true in order to export all names defined directly within the _included_ file.

The `@plutoinclude` macro accepts as additional inputs any number of assignments expression of the form `name = value` where `value` must be a `Bool`. These expression are parsed at the beginning of the macro expansion and grouped as `kwargs` that are passed to the `Base.names` call. One could example set the `all` kwarg to false as in the example below:
![image](https://github.com/disberd/SimplePlutoInclude.jl/assets/12846528/3abd2ac3-ce6d-40ac-8e54-a761ae205a6a)

> [!NOTE]
> Setting `all` to `false` will not export any name defined in the _included_ file unless something is explicitly marked with `export` or `public` within the file.

> [!NOTE]
> If you want to avoid exporting some specific variables from an included Pluto notebook, like for example the variables defined with `@bind`, consider marking them in the original notebook as _Disabled in file_, so they will be commented out in the source file and will not be _included_ in the temporary module generated by `@plutoinclude`.

## Alternatives
The functionality provided by the `@plutoinclude` macro is very similar to the `@ingredients` macro from [PlutoLinks.jl](https://github.com/JuliaPluto/PlutoLinks.jl). The main difference is the fact that while `@ingredients` does not explicitly import any name inside the calling Pluto notebook, `@plutoinclude` does.
This often simplifies interactive development as one does not need to always prepend the module name to access the variables defined within the file
> [!NOTE]
> `@ingredients` also tracks changes in the file and rerun dependent cells when updating the file. While a mode supporting `Revise` is planned for the next release of SimplePlutoInclude, automatic reload of dependent cells is not planned for this macro as the reload of the file is intended to only be done manually to accidentally avoid triggering long-running cells each time a file is changed. 
"""
macro plutoinclude(args...)
    caller = __module__
    path, kwargs = extract_kwargs(args, caller)
    plutoinclude(path, caller; kwargs...) |> esc
end

end # module SimplePlutoInclude
